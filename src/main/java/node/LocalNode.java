package node;

import network.exeptions.NetworkFailureException;
import network.nodeServer.NodeServer;
import network.remoteNode.RemoteNode;
import node.exceptions.NodeNotFoundException;
import resource.ChordResource;

import java.io.*;
import java.util.Scanner;

import static java.lang.Math.pow;
import static utils.Util.M;
import static utils.Util.isInsideInterval;

/**
 * Abstract implementation of the node on the local machine.
 * The local node is fully operative either by creating a ring (initially including only itself),
 * or by joining an existing node, The existing node can live on the same machine or remotely.
 */
public class LocalNode implements Node{

    private FingerTable fingerTable;
    private Node predecessor=this;
    private int next = 0;
    private int id;
    private NodeServer nodeServer;


    /**
     * Constructs a Node by specifying its identifier id and initialising its finger table entries to <pre>null</pre>.
     * However this constructor is still populating the keys ({@link FingerTableEntry#setStart(int)}
     * of the entries in the fingerTable, computing them from the entry's index and {@link utils.Util#M}
     * @param id the identifier for this node.
     *           This identifier shall be generated by a consistent hash function, computed on a singular information,
     *           as IP:PORT
     */
    public LocalNode(int id, String ip, int port) {
        this.id = id;
        fingerTable = new FingerTable(this);
        try {
            nodeServer = new NodeServer(this, ip, port);
            new Thread(this::stabilizeLoop).start();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /*
     * Node's methods overrides
     */

    @Override
    public Node findSuccessor(int id) throws NodeNotFoundException {
        if(isInsideInterval(id, predecessor.getId(), getId()))
            return this;
        else if(!isInsideInterval(id, this.getId(), this.getSuccessor().getId()) && id != this.getSuccessor().getId()){
            try {
                return closestPrecedingFinger(id).findSuccessor(id);
            } catch (NetworkFailureException e){
                e.printStackTrace();
            }
        }
        return new RemoteNode(getSuccessor().getId(), getSuccessor().getIp(), getSuccessor().getPort());
    }

    public Node closestPrecedingFinger(int id) {
        for(int i=M-1; i>=0; i--) {
            if (isInsideInterval(fingerTable.getNode(i).getId(), this.getId(), id))
                return fingerTable.getNode(i);
        }
        return this;
    }

    @Override
    public Node getSuccessor() {
            return fingerTable.getNode(0);
    }

    public void setSuccessor(Node n){
        fingerTable.setNode(0, n);
    }

    @Override
    synchronized public Node getPredecessor() {
        return predecessor;
    }

    synchronized public void setPredecessor(Node predecessor) {
        this.predecessor = predecessor;
    }

    @Override
    public void notifyPredecessor(Node n) {
        if(getPredecessor().getId() == n.getId())
            return;
        // TODO getPredecessor() would never be null since we initialize it as this
        if(getPredecessor() == null || isInsideInterval(n.getId(), getPredecessor().getId(), this.getId())) {
            if (getPredecessor() instanceof RemoteNode)
                ((RemoteNode) getPredecessor()).close();
            setPredecessor(n);
        }
    }

    @Override
    public void publish(ChordResource resource) {
        File file = new File("data/node_"+this.id + "/" +resource.getTitle());
        if(!file.exists()) {
            file.getParentFile().mkdirs();
        }
        try(PrintWriter writer = new PrintWriter(new FileOutputStream(file))) {
            writer.print(resource.getContent());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public ChordResource fetch(String name) {
        File file = new File("data/node_"+this.id + "/" +name);
        if(!file.exists())
            return new ChordResource(name, "");
        else{
            try(Scanner sc = new Scanner(new FileInputStream(file))) {
                String content = sc.nextLine();
                return new ChordResource(name, content);
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
        }
        return new ChordResource(name, "");
    }

    /*
     * Stabilization procedures
     */

    public void stabilize(){

        try {
            Node x = getSuccessor().getPredecessor();
            if(isInsideInterval(x.getId(), this.getId(), this.getSuccessor().getId()))
                setSuccessor(x);
            getSuccessor().notifyPredecessor(this);
        } catch (NodeNotFoundException | NetworkFailureException e) {
            e.printStackTrace();
        }
    }

    public void fixFingers(){
        next = next + 1;
        if(next >= M)
            next = 0;
        try{
            Node n = findSuccessor((this.getId()+(int)pow(2,next))%((int)pow(2,M)));
            fingerTable.setNode(next, n);
            /*
             *  Even if fixFingers cannot reach the node, will try it later by itself
             *  when `next` will have again the same value
             */
        } catch (NodeNotFoundException e) {
            e.printStackTrace();
        }
    }

    public void checkPredecessor(){
        //
    }

    /*
     * Overlay network construction, join or create one
     */

    /**
     * Joins the Chord ring which n belongs to.
     *
     * @param n the target node to join.
     * @throws NodeNotFoundException     when n is not available
     */
    public void join(Node n) throws NodeNotFoundException, NetworkFailureException {
        setPredecessor(this);
        Node successor = n.findSuccessor(getId());
        for(int i=0; i<M; i++){
            fingerTable.setNode(i, successor);
        }
    }

    private void stabilizeLoop(){

        while(true){
            stabilize();
            fixFingers();
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
                return;
            }
        }
    }


    /*
     * Getter and Setters
     */

    public int getId() {
        return id;
    }

    public FingerTable getFingerTable() {
        return fingerTable;
    }

    @Override
    public int getPort() {
        return nodeServer.getPort();
    }

    @Override
    public String getIp() {
        return nodeServer.getIp();
    }

    public FingerTable getFingertable(){
        return this.fingerTable;
    }
}
